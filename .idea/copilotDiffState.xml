<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Entrypoint limpo: chama o script de login.&#10;&quot;&quot;&quot;&#10;&#10;from pathlib import Path&#10;from datetime import datetime, timezone&#10;import argparse&#10;&#10;&#10;def _fallback_login(*args, **kwargs):&#10;    print(&quot;Módulo login_hotmart não disponível. Instale as dependências ou verifique o arquivo.&quot;)&#10;    return False&#10;&#10;# Tenta atribuir a função `login` do módulo `login_hotmart`, mas cai para o fallback se não existir.&#10;login = _fallback_login&#10;try:&#10;    import login_hotmart as _lh&#10;    if hasattr(_lh, &quot;login&quot;):&#10;        login = _lh.login&#10;except Exception:&#10;    # mantém o fallback&#10;    pass&#10;&#10;&#10;def _generate_task_id(history_root: Path = None) -&gt; str:&#10;    &quot;&quot;&quot;Gera um task_id no formato TASK-YYYYMMDD-NNN baseado nas pastas existentes em .history.&quot;&quot;&quot;&#10;    if history_root is None:&#10;        history_root = Path(__file__).resolve().parent / '.history'&#10;    history_root.mkdir(parents=True, exist_ok=True)&#10;    date_part = datetime.now(timezone.utc).strftime('%Y%m%d')&#10;    prefix = f&quot;TASK-{date_part}-&quot;&#10;    max_n = 0&#10;    try:&#10;        for child in history_root.iterdir():&#10;            if child.is_dir() and child.name.startswith(prefix):&#10;                suffix = child.name.replace(prefix, '')&#10;                try:&#10;                    n = int(suffix)&#10;                    if n &gt; max_n:&#10;                        max_n = n&#10;                except Exception:&#10;                    continue&#10;    except Exception:&#10;        pass&#10;    next_n = max_n + 1&#10;    return f&quot;{prefix}{next_n:03d}&quot;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    parser = argparse.ArgumentParser(description=&quot;Executa o login na Hotmart usando credenciais em .env&quot;)&#10;    group = parser.add_mutually_exclusive_group()&#10;    group.add_argument('--headless', dest='headless', action='store_true', help='Executar em modo headless (sem UI)')&#10;    group.add_argument('--no-headless', dest='headless', action='store_false', help='Executar com UI visível (headful) para depuração')&#10;    parser.set_defaults(headless=True)&#10;    parser.add_argument('--timeout', type=int, default=20, help='Timeout em segundos para operações do navegador')&#10;    parser.add_argument('--task-id', type=str, default=None, help='Task ID para logs/screenshots (gerado automaticamente se omitido)')&#10;    args = parser.parse_args()&#10;&#10;    # Gerar task_id automaticamente se não fornecido&#10;    if not args.task_id:&#10;        args.task_id = _generate_task_id()&#10;    # Garantir que exista a pasta da task no histórico&#10;    try:&#10;        (Path(__file__).resolve().parent / '.history' / args.task_id).mkdir(parents=True, exist_ok=True)&#10;    except Exception:&#10;        pass&#10;&#10;    # Executa o login usando as credenciais em .env&#10;    success = login(headless=args.headless, timeout=args.timeout, task_id=args.task_id)&#10;    if success:&#10;        print(&quot;Login realizado com sucesso.&quot;)&#10;    else:&#10;        print(&quot;Falha no login. Verifique .env, seletores e a conectividade.&quot;)&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Entrypoint limpo: chama o script de login.&#10;&quot;&quot;&quot;&#10;&#10;from pathlib import Path&#10;from datetime import datetime, timezone&#10;import argparse&#10;import json&#10;&#10;&#10;def _write_summary_entry(entry: dict):&#10;    &quot;&quot;&quot;Append a JSON line to .history/summary.log&quot;&quot;&quot;&#10;    try:&#10;        root = Path(__file__).resolve().parent&#10;        summary = root / '.history' / 'summary.log'&#10;        summary.parent.mkdir(parents=True, exist_ok=True)&#10;        with open(summary, 'a', encoding='utf-8') as f:&#10;            f.write(json.dumps(entry, ensure_ascii=False) + '\n')&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def _create_task_json(task_id: str, title: str, description: str):&#10;    &quot;&quot;&quot;Create an initial task.json under .history/&lt;task_id&gt;/task.json&quot;&quot;&quot;&#10;    try:&#10;        root = Path(__file__).resolve().parent&#10;        task_dir = root / '.history' / task_id&#10;        task_dir.mkdir(parents=True, exist_ok=True)&#10;        now = datetime.now(timezone.utc).isoformat()&#10;        task_meta = {&#10;            &quot;task_id&quot;: task_id,&#10;            &quot;title&quot;: title,&#10;            &quot;description&quot;: description,&#10;            &quot;created_at&quot;: now,&#10;            &quot;updated_at&quot;: now,&#10;            &quot;status&quot;: &quot;Pendente&quot;,&#10;            &quot;context_snapshot&quot;: {},&#10;            &quot;actions&quot;: [],&#10;            &quot;decisions&quot;: [],&#10;            &quot;next_steps&quot;: &quot;&quot;&#10;        }&#10;        with open(task_dir / 'task.json', 'w', encoding='utf-8') as f:&#10;            json.dump(task_meta, f, ensure_ascii=False, indent=2)&#10;    except Exception:&#10;        pass&#10;&#10;&#10;def _fallback_login(*args, **kwargs):&#10;    print(&quot;Módulo login_hotmart não disponível. Instale as dependências ou verifique o arquivo.&quot;)&#10;    return False&#10;&#10;# Tenta atribuir a função `login` do módulo `login_hotmart`, mas cai para o fallback se não existir.&#10;login = _fallback_login&#10;try:&#10;    import login_hotmart as _lh&#10;    if hasattr(_lh, &quot;login&quot;):&#10;        login = _lh.login&#10;except Exception:&#10;    # mantém o fallback&#10;    pass&#10;&#10;&#10;def _generate_task_id(history_root: Path = None) -&gt; str:&#10;    &quot;&quot;&quot;Gera um task_id no formato TASK-YYYYMMDD-NNN baseado nas pastas existentes em .history.&quot;&quot;&quot;&#10;    if history_root is None:&#10;        history_root = Path(__file__).resolve().parent / '.history'&#10;    history_root.mkdir(parents=True, exist_ok=True)&#10;    date_part = datetime.now(timezone.utc).strftime('%Y%m%d')&#10;    prefix = f&quot;TASK-{date_part}-&quot;&#10;    max_n = 0&#10;    try:&#10;        for child in history_root.iterdir():&#10;            if child.is_dir() and child.name.startswith(prefix):&#10;                suffix = child.name.replace(prefix, '')&#10;                try:&#10;                    n = int(suffix)&#10;                    if n &gt; max_n:&#10;                        max_n = n&#10;                except Exception:&#10;                    continue&#10;    except Exception:&#10;        pass&#10;    next_n = max_n + 1&#10;    return f&quot;{prefix}{next_n:03d}&quot;&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    parser = argparse.ArgumentParser(description=&quot;Executa o login na Hotmart usando credenciais em .env&quot;)&#10;    group = parser.add_mutually_exclusive_group()&#10;    group.add_argument('--headless', dest='headless', action='store_true', help='Executar em modo headless (sem UI)')&#10;    group.add_argument('--no-headless', dest='headless', action='store_false', help='Executar com UI visível (headful) para depuração')&#10;    parser.set_defaults(headless=True)&#10;    parser.add_argument('--timeout', type=int, default=20, help='Timeout em segundos para operações do navegador')&#10;    parser.add_argument('--task-id', type=str, default=None, help='Task ID para logs/screenshots (gerado automaticamente se omitido)')&#10;    args = parser.parse_args()&#10;&#10;    # Gerar task_id automaticamente se não fornecido&#10;    auto_generated = False&#10;    if not args.task_id:&#10;        args.task_id = _generate_task_id()&#10;        auto_generated = True&#10;    # Garantir que exista a pasta da task no histórico&#10;    try:&#10;        (Path(__file__).resolve().parent / '.history' / args.task_id).mkdir(parents=True, exist_ok=True)&#10;    except Exception:&#10;        pass&#10;&#10;    # Se a task foi gerada automaticamente, registrar no summary.log e criar task.json&#10;    if auto_generated:&#10;        now_iso = datetime.now(timezone.utc).isoformat()&#10;        summary_entry = {&quot;date&quot;: now_iso, &quot;task_id&quot;: args.task_id, &quot;title&quot;: &quot;Automated login run&quot;, &quot;status&quot;: &quot;Pendente&quot;}&#10;        _write_summary_entry(summary_entry)&#10;        _create_task_json(args.task_id, &quot;Automated login run&quot;, &quot;Task gerada automaticamente para execução de login via script&quot;)&#10;&#10;    # Executa o login usando as credenciais em .env&#10;    success = login(headless=args.headless, timeout=args.timeout, task_id=args.task_id)&#10;    if success:&#10;        print(&quot;Login realizado com sucesso.&quot;)&#10;    else:&#10;        print(&quot;Falha no login. Verifique .env, seletores e a conectividade.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>